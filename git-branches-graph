#!/usr/bin/env python3
"""
git_branches_graph.py
---------------------

Visualise relationships between Git branches.

The script:

1. Verifies it is executed inside a Git working tree.
2. Collects branch names either automatically (`git branch --format '%(refname:short)'`)
   or from explicit user-supplied lists (CLI parameters or standard input).
   Leading markers produced by `git branch` such as “* ” or “+ ” are stripped.
   • Use --all/-a flag to include remote branches (similar to `git branch --all`)
3. For every pair of branches it finds their *nearest common ancestor* via
   `git merge-base`.  
   • If the ancestor **commit** is pointed-to by an existing branch, that branch
     name is used as the node label.  
   • Otherwise the commit is referred to by its shortest unique abbreviation
     (`git rev-parse --short=<n>` is attempted, falling back to 7 chars).
4. Produces a simple *directed* graph where each common-ancestor node points to
   the two (or more) branch tips that diverge from it.
5. Supports five output formats selectable with `--format`:
     • mermaid  (default)  –  “graph LR; A --> B;”
     • dot/graphviz        –  “digraph { A -> B }”
     • csv                 –  “from,to”
     • png                 –  Renders to PNG via Graphviz
     • html                –  Interactive HTML with pan/zoom using Mermaid
6. Prints to STDOUT, making it easy to pipe into `dot -Tpng`, `mmdc`, etc.
   • Use --browser with HTML format to serve locally and open in browser

IMPORTANT NOTE about --all flag:
When multiple branches (local and/or remote) point to the same commit, only one
branch name will be shown in the graph for that commit. This is because the graph
uses commits as nodes, not branches. For example, if both 'master' and 
'origin/master' point to commit abc123, the graph will show only one of these
branch names (typically the last one alphabetically) as the label for that node.

EXPERIMENTAL --cluster-same-commit flag:
This experimental feature groups branches pointing to the same commit into visual
clusters (subgraphs in Mermaid, clusters in Graphviz). This allows you to see ALL
branch names even when multiple branches point to the same commit. The branches are
grouped together in a box/cluster, making it clear they reference the same commit.
Note: This feature may produce more complex graphs and is still being refined.

Example
-------

    # Auto-detect local branches and print Mermaid
    ./git_branches_graph.py

    # Provide explicit branch names
    ./git_branches_graph.py feature/login bugfix/email --format dot

    # Read branch names from STDIN (could be `git branch` output)
    git branch | ./git_branches_graph.py --stdin -f csv

    # Include remote branches in the graph
    ./git_branches_graph.py --all

    # [EXPERIMENTAL] Show all branches in clusters when they point to same commit
    ./git_branches_graph.py --all --cluster-same-commit

    # Generate interactive HTML with pan/zoom
    ./git_branches_graph.py --format html --output graph.html

    # Open HTML directly in browser (serves on local server)
    ./git_branches_graph.py --format html --browser
"""
from __future__ import annotations

import argparse
import itertools
import os
import shlex
import subprocess
import sys
import http.server
import socketserver
import threading
import webbrowser
from pathlib import Path
from typing import Dict, Iterable, List, Set, Tuple
from collections import deque

# Repository path selected by --repo option; set in main()
GIT_REPO: Path | None = None

# --------------------------------------------------------------------------- #
# Helpers                                                                     #
# --------------------------------------------------------------------------- #


def run_git(*args: str) -> str:
    """Run a git command (optionally inside --repo path) and return stdout stripped."""
    cmd = ["git"]
    if GIT_REPO is not None:
        cmd += ["-C", str(GIT_REPO)]
    cmd += list(args)
    try:
        out = subprocess.check_output(cmd, text=True)
    except subprocess.CalledProcessError as exc:
        sys.stderr.write(f"error: {' '.join(cmd)} failed: {exc}\n")
        sys.exit(2)
    return out.strip()

# --- new helper ----------------------------------------------------------- #
def _try_git_rev_parse(ref: str) -> str | None:
    """
    Run `git rev-parse <ref>` but **do NOT exit** when it fails.
    Returns the SHA (stripped) or None when the ref does not exist.
    """
    cmd = ["git"]
    if GIT_REPO is not None:
        cmd += ["-C", str(GIT_REPO)]
    cmd += ["rev-parse", ref]
    try:
        return subprocess.check_output(cmd, text=True).strip()
    except subprocess.CalledProcessError:
        return None

def resolve_name_to_commit(name: str) -> str:
    """
    Resolve *name* to a commit SHA while giving priority to real branches:
        1. refs/heads/<name>          (local branch)
        2. refs/remotes/<name>        (remote branch)
        3. <name>                     (fallback – tag, SHA, etc.)
    Exits with error if nothing resolves.
    """
    for full_ref in (f"refs/heads/{name}",
                     f"refs/remotes/{name}",
                     name):
        sha = _try_git_rev_parse(full_ref)
        if sha:
            return sha

    sys.stderr.write(f"fatal: could not resolve '{name}' to a commit\n")
    sys.exit(1)


def ensure_git_repo() -> None:
    """Abort if we are not inside a git repository."""
    try:
        inside = run_git("rev-parse", "--is-inside-work-tree")
    except SystemExit:
        raise
    except Exception:
        inside = "false"

    if inside != "true":
        sys.stderr.write("fatal: not a git repository (or any of the parent directories)\n")
        sys.exit(1)


def strip_branch_marker(name: str) -> str:
    """Remove markers such as '* ' or '+ ' added by `git branch` output."""
    return name.lstrip("*+ ").strip()


def abbreviate_commit(commit: str) -> str:
    """Return shortest unique abbreviation; fall back to 7 chars."""
    try:
        return run_git("rev-parse", "--short", commit)
    except Exception:
        return commit[:7]


# --------------------------------------------------------------------------- #
# Graph computation                                                           #
# --------------------------------------------------------------------------- #


def collect_branches(use_stdin: bool, explicit: List[str], include_all: bool = False) -> List[str]:
    if use_stdin:
        names = [strip_branch_marker(line) for line in sys.stdin.read().splitlines() if line.strip()]
    elif explicit:
        names = [strip_branch_marker(n) for n in explicit]
    else:
        # All local branches (or all branches if include_all is True)
        if include_all:
            raw = run_git("branch", "--all", "--format=%(refname:short)").splitlines()
        else:
            raw = run_git("branch", "--format=%(refname:short)").splitlines()
        names = [strip_branch_marker(r) for r in raw if r.strip()]
    if not names:
        sys.stderr.write("error: no branches detected / specified\n")
        sys.exit(1)
    return sorted(set(names))


def map_branches_to_commits(branches: Iterable[str]) -> Dict[str, str]:
    # OLD: return {br: run_git("rev-parse", br) for br in branches}
    return {br: resolve_name_to_commit(br) for br in branches}


def common_ancestor(a_commit: str, b_commit: str) -> str | None:
    """
    Return the merge-base of two commits or None if the commits have no
    common ancestor (git exits with status 1 in that case).
    """
    cmd: List[str] = ["git"]
    if GIT_REPO is not None:
        cmd += ["-C", str(GIT_REPO)]
    cmd += ["merge-base", a_commit, b_commit]
    try:
        return subprocess.check_output(cmd, text=True).strip()
    except subprocess.CalledProcessError:
        # unrelated histories
        return None


def build_graph(branch_commits: Dict[str, str], cluster_same_commit: bool = False) -> Tuple[Set[Tuple[str, str]], Dict[str, str], Dict[str, List[str]]]:
    """
    Discover all common-ancestor vertices (recursively) and build the full edge
    set. New ancestors discovered during the process are themselves compared
    with every other vertex until no new vertices appear.
    Returns:
        edges: Set[(parent_label, child_label)]
        node_labels: Map commit_sha -> chosen label
        commit_branches: Map commit_sha -> list of branch names (for clustering)
    """
    # Track all branches pointing to each commit
    commit_branches: Dict[str, List[str]] = {}
    for br, sha in branch_commits.items():
        commit_branches.setdefault(sha, []).append(br)
    
    # Initial labels (branch names for tips)
    if cluster_same_commit:
        # Use commit SHA as label when clustering
        node_labels: Dict[str, str] = {sha: sha for sha in branch_commits.values()}
    else:
        # Use last branch name as label (original behavior)
        node_labels: Dict[str, str] = {sha: br for br, sha in branch_commits.items()}
    vertices: List[str] = list(branch_commits.values())  # queue-like list

    edges: Set[Tuple[str, str]] = set()
    idx = 0  # index of vertex to start pairing from
    while idx < len(vertices):
        current_subset = vertices[idx:]
        idx = len(vertices)  # next iteration will start where new vertices begin

        # Compare every unordered pair within the current subset and all previous vertices
        for sha1 in vertices:
            for sha2 in current_subset:
                if sha1 >= sha2:  # ensure each unordered pair processed once
                    continue
                anc = common_ancestor(sha1, sha2)
                if not anc:
                    continue  # unrelated histories

                # register ancestor label (once)
                if anc not in node_labels:
                    node_labels[anc] = abbreviate_commit(anc)
                    vertices.append(anc)  # newly discovered, will be processed in later rounds

                # add edges ancestor -> child (skip self-referential edges)
                if node_labels[anc] != node_labels[sha1]:
                    edges.add((node_labels[anc], node_labels[sha1]))
                if node_labels[anc] != node_labels[sha2]:
                    edges.add((node_labels[anc], node_labels[sha2]))

    return edges, node_labels, commit_branches


# --------------------------------------------------------------------------- #
# Transitive reduction                                                        #
# --------------------------------------------------------------------------- #


def transitive_reduction(edges: Set[Tuple[str, str]]) -> Set[Tuple[str, str]]:
    """
    Perform transitive reduction on a DAG represented by *edges*.
    Removes every edge (u, v) for which an alternative path u ~~> v exists.
    """
    # Build adjacency list
    adj: Dict[str, Set[str]] = {}
    for u, v in edges:
        adj.setdefault(u, set()).add(v)

    def reachable(src: str, dst: str, skip_edge: Tuple[str, str]) -> bool:
        """DFS reachability ignoring *skip_edge*."""
        stack = [src]
        seen = {src}
        while stack:
            u = stack.pop()
            for w in adj.get(u, ()):
                if (u, w) == skip_edge:
                    continue
                if w == dst:
                    return True
                if w not in seen:
                    seen.add(w)
                    stack.append(w)
        return False

    reduced: Set[Tuple[str, str]] = set()
    for edge in edges:
        u, v = edge
        if not reachable(u, v, edge):
            reduced.add(edge)
    return reduced


# --------------------------------------------------------------------------- #
# Output renderers                                                            #
# --------------------------------------------------------------------------- #


def render_mermaid(edges: Set[Tuple[str, str]], node_labels: Dict[str, str] = None, 
                   commit_branches: Dict[str, List[str]] = None, cluster_same_commit: bool = False) -> str:
    lines = ["graph LR"]
    
    if cluster_same_commit and commit_branches and node_labels:
        # Track which commits we've already rendered in subgraphs
        rendered_commits = set()
        subgraph_counter = 0
        
        # Create subgraphs for commits with multiple branches
        for sha, branches in commit_branches.items():
            if len(branches) > 1 and sha in node_labels:
                subgraph_counter += 1
                lines.append(f"    subgraph cluster_{subgraph_counter}[\" \"]")
                for branch in sorted(branches):
                    lines.append(f"        {shlex.quote(branch)}[{shlex.quote(branch)}]")
                lines.append("    end")
                rendered_commits.add(sha)
        
        # Render edges, using branch names for multi-branch commits
        for parent, child in sorted(edges):
            # Determine actual nodes to connect
            parent_branches = []
            child_branches = []
            
            # Find branches for parent
            for sha, branches in commit_branches.items():
                if node_labels.get(sha) == parent:
                    parent_branches = branches if len(branches) > 1 else [parent]
                    break
            if not parent_branches:
                parent_branches = [parent]
                
            # Find branches for child  
            for sha, branches in commit_branches.items():
                if node_labels.get(sha) == child:
                    child_branches = branches if len(branches) > 1 else [child]
                    break
            if not child_branches:
                child_branches = [child]
            
            # Connect all combinations
            for p in parent_branches:
                for c in child_branches:
                    lines.append(f"    {shlex.quote(p)} --> {shlex.quote(c)}")
    else:
        # Original behavior
        for parent, child in sorted(edges):
            lines.append(f"    {shlex.quote(parent)} --> {shlex.quote(child)}")
    
    return "\n".join(lines)


def render_png(edges: Set[Tuple[str, str]], node_labels: Dict[str, str] = None,
               commit_branches: Dict[str, List[str]] = None, cluster_same_commit: bool = False) -> bytes:
    """Render PNG via Graphviz `dot`."""
    dot_src = render_dot(edges, node_labels, commit_branches, cluster_same_commit)
    try:
        # Pass graphviz DOT source as bytes and receive binary PNG data.
        png_data = subprocess.check_output(
            ["dot", "-Tpng"],
            input=dot_src.encode(),
        )
    except FileNotFoundError:
        sys.stderr.write("error: graphviz `dot` executable not found. Install graphviz.\n")
        sys.exit(2)
    except subprocess.CalledProcessError as exc:
        sys.stderr.write(f"error: dot failed: {exc}\n")
        sys.exit(2)
    return png_data


def render_dot(edges: Set[Tuple[str, str]], node_labels: Dict[str, str] = None,
               commit_branches: Dict[str, List[str]] = None, cluster_same_commit: bool = False) -> str:
    lines = ["digraph G {"]
    lines.append('    rankdir="LR";')  # Left to right layout like Mermaid
    
    if cluster_same_commit and commit_branches and node_labels:
        subgraph_counter = 0
        
        # Create clusters for commits with multiple branches
        for sha, branches in commit_branches.items():
            if len(branches) > 1 and sha in node_labels:
                subgraph_counter += 1
                lines.append(f'    subgraph cluster_{subgraph_counter} {{')
                lines.append('        style="rounded,filled";')
                lines.append('        fillcolor="lightgray";')
                lines.append(f'        label="";')
                for branch in sorted(branches):
                    lines.append(f'        "{branch}";')
                lines.append('    }')
        
        # Render edges
        for parent, child in sorted(edges):
            # Find branches for parent and child
            parent_branches = []
            child_branches = []
            
            for sha, branches in commit_branches.items():
                if node_labels.get(sha) == parent:
                    parent_branches = branches if len(branches) > 1 else [parent]
                if node_labels.get(sha) == child:
                    child_branches = branches if len(branches) > 1 else [child]
                    
            if not parent_branches:
                parent_branches = [parent]
            if not child_branches:
                child_branches = [child]
                
            # Connect branches
            for p in parent_branches:
                for c in child_branches:
                    lines.append(f'    "{p}" -> "{c}";')
    else:
        # Original behavior
        for parent, child in sorted(edges):
            lines.append(f'    "{parent}" -> "{child}";')
    
    lines.append("}")
    return "\n".join(lines)


def render_csv(edges: Set[Tuple[str, str]]) -> str:
    lines = ["from,to"]
    lines += [f"{parent},{child}" for parent, child in sorted(edges)]
    return "\n".join(lines)


def render_html(mermaid_content: str, template_path: str = "/home/gw-t490/d/25Q2/code/mermaid_html_template_with_zoom_and_panning.html") -> str:
    """Render HTML with embedded Mermaid diagram using the template."""
    try:
        # Read the template
        template = Path(template_path).read_text()
        
        # Find where to insert the Mermaid content
        # The template has a placeholder diagram, we need to replace it
        # Look for the mermaid div content
        start_marker = '<div id="diagramContainer" class="mermaid">'
        end_marker = '</div>'
        
        start_idx = template.find(start_marker)
        if start_idx == -1:
            raise ValueError("Could not find mermaid container in template")
        
        # Find the closing tag for this specific div
        start_idx += len(start_marker)
        end_idx = template.find(end_marker, start_idx)
        if end_idx == -1:
            raise ValueError("Could not find closing tag for mermaid container")
        
        # Replace the content between the markers
        html = template[:start_idx] + "\n      " + mermaid_content + "\n    " + template[end_idx:]
        
        return html
    except Exception as e:
        sys.stderr.write(f"error: failed to render HTML: {e}\n")
        sys.exit(2)


def serve_and_open_html(html_content: str, port: int = 0) -> None:
    """Start a local HTTP server and open the HTML in a browser."""
    import tempfile
    
    # Create a temporary directory for serving
    with tempfile.TemporaryDirectory() as tmpdir:
        html_path = Path(tmpdir) / "graph.html"
        html_path.write_text(html_content)
        
        # Find an available port
        with socketserver.TCPServer(("", port), http.server.SimpleHTTPRequestHandler) as httpd:
            actual_port = httpd.server_address[1]
            url = f"http://localhost:{actual_port}/graph.html"
            
            # Change to temporary directory for serving
            os.chdir(tmpdir)
            
            # Open browser in a separate thread
            def open_browser():
                import time
                time.sleep(0.5)  # Give server time to start
                webbrowser.open(url)
            
            browser_thread = threading.Thread(target=open_browser)
            browser_thread.daemon = True
            browser_thread.start()
            
            print(f"Serving at {url}")
            print("Press Ctrl+C to stop the server")
            
            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                print("\nServer stopped")


# --------------------------------------------------------------------------- #
# CLI                                                                         #
# --------------------------------------------------------------------------- #


def parse_args(argv: List[str] | None = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Produce a simple graph (Mermaid, Graphviz, CSV) showing common ancestors of Git branches."
    )
    p.add_argument(
        "branches",
        nargs="*",
        help="Branch names to include. If omitted all local branches are used.",
    )
    p.add_argument(
        "-s",
        "--stdin",
        action="store_true",
        help="Read branch names from standard input (one per line, accepts `git branch` raw output).",
    )
    p.add_argument(
        "-a",
        "--all",
        action="store_true",
        help="Include remote branches in addition to local branches.",
    )
    p.add_argument(
        "-r",
        "--repo",
        default=".",
        help="Path to a git repository to inspect (default: current directory).",
    )
    p.add_argument(
        "-f",
        "--format",
        choices=("mermaid", "dot", "csv", "png", "html"),
        default="mermaid",
        help="Output format (default: mermaid).",
    )
    p.add_argument(
        "-o",
        "--output",
        help="Write output to given file path. "
             "When --format png and this flag is omitted the script "
             "auto-creates graph.png / graph.<n>.png in the CWD.",
    )
    p.add_argument(
        "-C",
        "--cluster-same-commit",
        action="store_true",
        help="[EXPERIMENTAL] Group branches pointing to the same commit into clusters/subgraphs. "
             "Shows all branch names instead of just one per commit.",
    )
    p.add_argument(
        "-B",
        "--browser",
        action="store_true",
        help="When using HTML format, start a local server and open in browser.",
    )
    return p.parse_args(argv)


def main(argv: List[str] | None = None) -> None:
    args = parse_args(argv)
    
    # If --browser is specified, default to HTML format unless explicitly overridden
    if args.browser and args.format == "mermaid":  # mermaid is the default
        args.format = "html"

    # If the first positional argument looks like a directory that is a git
    # repository, treat it as the --repo path (for convenience).
    if args.repo == "." and args.branches:
        candidate_repo = Path(args.branches[0]).expanduser().resolve()
        if candidate_repo.is_dir() and (candidate_repo / ".git").exists():
            args.repo = str(candidate_repo)
            args.branches = args.branches[1:]

    global GIT_REPO
    GIT_REPO = Path(args.repo).expanduser().resolve()
    if not GIT_REPO.exists():
        sys.stderr.write(f"fatal: path '{GIT_REPO}' does not exist\n")
        sys.exit(1)

    ensure_git_repo()

    branches = collect_branches(args.stdin, args.branches, args.all)
    branch_commits = map_branches_to_commits(branches)
    edges, node_labels, commit_branches = build_graph(branch_commits, args.cluster_same_commit)
    edges = transitive_reduction(edges)

    def write_text(text: str) -> None:
        if args.output:
            Path(args.output).expanduser().write_text(text + "\n")
        else:
            sys.stdout.write(text + "\n")

    if args.format == "mermaid":
        write_text(render_mermaid(edges, node_labels, commit_branches, args.cluster_same_commit))
    elif args.format == "dot":
        write_text(render_dot(edges, node_labels, commit_branches, args.cluster_same_commit))
    elif args.format == "csv":
        write_text(render_csv(edges))
    elif args.format == "html":
        # Generate Mermaid content first
        mermaid_content = render_mermaid(edges, node_labels, commit_branches, args.cluster_same_commit)
        html_content = render_html(mermaid_content)
        
        if args.browser:
            # Serve and open in browser
            serve_and_open_html(html_content)
        else:
            # Write to file or stdout
            write_text(html_content)
    else:  # png
        png_bytes = render_png(edges, node_labels, commit_branches, args.cluster_same_commit)

        # Determine output path
        if args.output:
            out_path = Path(args.output).expanduser()
        else:
            suffix = ""
            i = 0
            while True:
                candidate = Path(f"graph{suffix}.png")
                if not candidate.exists():
                    out_path = candidate
                    break
                i += 1
                suffix = f".{i}"

        out_path.write_bytes(png_bytes)
        sys.stderr.write(f"INFO: created file '{out_path}' ({len(png_bytes)} bytes)\n")


if __name__ == "__main__":
    main()
